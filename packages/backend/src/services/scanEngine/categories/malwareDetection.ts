/**
 * Category 5: Malware Detection (45 points)
 *
 * Checks:
 * - Suspicious scripts (malware signatures: 15 pts)
 * - Drive-by download attempts (12 pts)
 * - Iframe injections (10 pts)
 * - Exploit kit indicators (10 pts)
 * - Suspicious file downloads (8 pts)
 * - Cryptominer detection (7 pts)
 *
 * Runs in: FULL pipeline only (requires full HTTP analysis)
 */

import {
  CategoryAnalyzer,
  CategoryResult,
  CategoryContext,
  Finding
} from '../categoryBase.js';
import { ReachabilityState } from '../types.js';
import { logger } from '../../../config/logger.js';

export class MalwareDetectionCategory extends CategoryAnalyzer {
  // Known malware/exploit patterns
  private static readonly MALWARE_SIGNATURES = [
    /cryptonight|coinhive|webminer|minero/i,  // Cryptominers
    /exploit|shellcode|payload/i,
    /backdoor|trojan|ransomware/i,
    /\/etc\/passwd|\/etc\/shadow/i,  // Path traversal
    /\.\.\/\.\.\//,  // Directory traversal
    /<script[^>]*src\s*=\s*["']data:/i  // Data URI scripts
  ];

  // Exploit kit indicators
  private static readonly EXPLOIT_KIT_PATTERNS = [
    /angler|neutrino|rig|magnitude|fallout/i,  // Known EK names
    /\/flash\/[a-f0-9]{32}/i,  // Flash exploit patterns
    /\.swf\?[a-z0-9]{20,}/i,
    /landing\.php|gate\.php/i
  ];

  // Suspicious file extensions
  private static readonly SUSPICIOUS_EXTENSIONS = [
    '.exe', '.dll', '.bat', '.cmd', '.vbs', '.ps1',
    '.scr', '.com', '.pif', '.msi', '.jar', '.apk'
  ];

  constructor() {
    super('malwareDetection', 'Malware Detection');
  }

  shouldRun(reachabilityState: ReachabilityState, pipelineType: string): boolean {
    // Only run for ONLINE state (need full HTTP response)
    return reachabilityState === ReachabilityState.ONLINE;
  }

  async analyze(context: CategoryContext): Promise<CategoryResult> {
    const startTime = Date.now();
    const findings: Finding[] = [];
    const config = context.config.malwareDetection;

    if (!context.httpResponse?.body) {
      return this.createSkippedResult('No HTTP response body', config.maxWeight);
    }

    const body = context.httpResponse.body;

    logger.debug(`[Malware Detection] Starting analysis for: ${context.url}`);

    // Check 1: Suspicious Scripts (malware signatures)
    const scriptFindings = this.checkSuspiciousScripts(body, config.checkWeights);
    findings.push(...scriptFindings);

    // Check 2: Drive-by Download Attempts
    const downloadFindings = this.checkDriveByDownloads(body, config.checkWeights);
    findings.push(...downloadFindings);

    // Check 3: Iframe Injections
    const iframeFindings = this.checkIframeInjections(body, config.checkWeights);
    findings.push(...iframeFindings);

    // Check 4: Exploit Kit Indicators
    const exploitFindings = this.checkExploitKits(body, config.checkWeights);
    findings.push(...exploitFindings);

    // Check 5: Suspicious File Downloads
    const fileFindings = this.checkSuspiciousFiles(body, config.checkWeights);
    findings.push(...fileFindings);

    // Check 6: Cryptominer Detection
    const cryptoFindings = this.checkCryptominers(body, config.checkWeights);
    findings.push(...cryptoFindings);

    const score = this.calculateScore(findings, config.maxWeight);
    const duration = Date.now() - startTime;

    logger.info(`[Malware Detection] Complete: ${score}/${config.maxWeight} points, ${findings.length} findings (${duration}ms)`);

    return {
      categoryId: this.categoryId,
      categoryName: this.categoryName,
      score,
      maxWeight: config.maxWeight,
      findings,
      metadata: {
        checksRun: 6,
        checksSkipped: 0,
        duration,
        skipped: false
      }
    };
  }

  private checkSuspiciousScripts(body: string, weights: Record<string, number>): Finding[] {
    const findings: Finding[] = [];
    const matched: string[] = [];

    for (const pattern of MalwareDetectionCategory.MALWARE_SIGNATURES) {
      if (pattern.test(body)) {
        matched.push(pattern.source);
      }
    }

    if (matched.length > 0) {
      findings.push(this.createFinding(
        'malware_suspicious_script',
        'Suspicious Script Pattern',
        'critical',
        weights.malware_suspicious_script || 15,
        `Detected ${matched.length} malware signature(s)`,
        { patterns: matched }
      ));
    }

    return findings;
  }

  private checkDriveByDownloads(body: string, weights: Record<string, number>): Finding[] {
    const findings: Finding[] = [];

    // Auto-download patterns
    const autoDownload = /<a[^>]*download[^>]*>/i.test(body) ||
                        /window\.open.*\.exe/i.test(body) ||
                        /location\.href\s*=.*\.(exe|dll|bat)/i.test(body);

    if (autoDownload) {
      findings.push(this.createFinding(
        'malware_drive_by_download',
        'Drive-by Download Detected',
        'critical',
        weights.malware_drive_by_download || 15,
        'Page attempts automatic file download',
        {}
      ));
    }

    return findings;
  }

  private checkIframeInjections(body: string, weights: Record<string, number>): Finding[] {
    const findings: Finding[] = [];
    const iframes = body.match(/<iframe[^>]*>/gi) || [];
    let suspiciousCount = 0;

    for (const iframe of iframes) {
      // Check for suspicious iframe attributes
      const isSuspicious = /width\s*=\s*["']1["']/i.test(iframe) ||
                          /height\s*=\s*["']1["']/i.test(iframe) ||
                          /style\s*=\s*["'][^"']*position\s*:\s*absolute[^"']*left\s*:\s*-9999/i.test(iframe);

      if (isSuspicious) {
        suspiciousCount++;
      }
    }

    if (suspiciousCount > 0) {
      findings.push(this.createFinding(
        'malware_iframe_injection',
        'Suspicious Iframe Injection',
        'high',
        weights.malware_iframe_injection || 12,
        `Found ${suspiciousCount} suspicious iframe(s)`,
        { count: suspiciousCount }
      ));
    }

    return findings;
  }

  private checkExploitKits(body: string, weights: Record<string, number>): Finding[] {
    const findings: Finding[] = [];

    for (const pattern of MalwareDetectionCategory.EXPLOIT_KIT_PATTERNS) {
      if (pattern.test(body)) {
        findings.push(this.createFinding(
          'malware_exploit_kit',
          'Exploit Kit Indicator',
          'critical',
          weights.malware_exploit_kit || 15,
          'Detected exploit kit patterns',
          { pattern: pattern.source }
        ));
        break;
      }
    }

    return findings;
  }

  private checkSuspiciousFiles(body: string, weights: Record<string, number>): Finding[] {
    const findings: Finding[] = [];
    const links = body.match(/href\s*=\s*["'][^"']+["']/gi) || [];
    const suspiciousFiles: string[] = [];

    for (const link of links) {
      for (const ext of MalwareDetectionCategory.SUSPICIOUS_EXTENSIONS) {
        if (link.toLowerCase().includes(ext)) {
          const match = link.match(/["']([^"']+)["']/);
          if (match) suspiciousFiles.push(match[1]);
        }
      }
    }

    if (suspiciousFiles.length > 0) {
      findings.push(this.createFinding(
        'malware_suspicious_file_download',
        'Suspicious File Downloads',
        'high',
        weights.malware_suspicious_file_download || 10,
        `Links to ${suspiciousFiles.length} executable file(s)`,
        { files: suspiciousFiles.slice(0, 5) }
      ));
    }

    return findings;
  }

  private checkCryptominers(body: string, weights: Record<string, number>): Finding[] {
    const findings: Finding[] = [];

    const cryptoPatterns = [
      /coinhive/i,
      /cryptonight/i,
      /webminer/i,
      /minero/i,
      /crypto-loot/i,
      /coin-hive/i
    ];

    for (const pattern of cryptoPatterns) {
      if (pattern.test(body)) {
        findings.push(this.createFinding(
          'malware_cryptominer',
          'Cryptominer Detected',
          'high',
          weights.malware_cryptominer || 12,
          'Page contains cryptocurrency mining script',
          { pattern: pattern.source }
        ));
        break;
      }
    }

    return findings;
  }
}
