/**
 * Category 10: Technical Exploits (15 points)
 *
 * Checks:
 * - XSS vulnerability indicators (6 pts)
 * - CSRF vulnerability indicators (4 pts)
 * - Clickjacking attempts (3 pts)
 * - Protocol handler abuse (2 pts)
 *
 * Runs in: FULL pipeline
 */

import {
  CategoryAnalyzer,
  CategoryResult,
  CategoryContext,
  Finding
} from '../categoryBase.js';
import { ReachabilityState } from '../types.js';
import { logger } from '../../../config/logger.js';

export class TechnicalExploitsCategory extends CategoryAnalyzer {
  // XSS vulnerability indicators
  private static readonly XSS_PATTERNS = [
    /<script[^>]*>[\s\S]*?<\/script>/gi,
    /javascript:/gi,
    /onerror\s*=/gi,
    /onload\s*=/gi,
    /onclick\s*=/gi,
    /document\.write/gi,
    /innerHTML/gi
  ];

  // CSRF indicators
  private static readonly CSRF_PATTERNS = [
    /<form[^>]*method\s*=\s*["']post["'][^>]*>/gi,
    /type\s*=\s*["']hidden["']/gi
  ];

  // Clickjacking attempts
  private static readonly CLICKJACKING_PATTERNS = [
    /opacity\s*:\s*0/i,
    /position\s*:\s*absolute.*z-index\s*:\s*999/i,
    /visibility\s*:\s*hidden/i,
    /<iframe[^>]*style[^>]*position\s*:\s*absolute/i
  ];

  // Protocol handler abuse
  private static readonly PROTOCOL_PATTERNS = [
    /href\s*=\s*["']data:/gi,
    /href\s*=\s*["']javascript:/gi,
    /href\s*=\s*["']file:/gi,
    /href\s*=\s*["']vbscript:/gi
  ];

  constructor() {
    super('technicalExploits', 'Technical Exploits');
  }

  shouldRun(reachabilityState: ReachabilityState, pipelineType: string): boolean {
    return reachabilityState === ReachabilityState.ONLINE;
  }

  async analyze(context: CategoryContext): Promise<CategoryResult> {
    const startTime = Date.now();
    const findings: Finding[] = [];
    const config = context.config.technicalExploits;

    if (!context.httpResponse?.body) {
      return this.createSkippedResult('No HTTP response body', config.maxWeight);
    }

    const body = context.httpResponse.body;

    logger.debug(`[Technical Exploits] Analyzing for: ${context.url}`);

    // Check 1: XSS Indicators
    const xssFindings = this.checkXSS(body, config.checkWeights);
    findings.push(...xssFindings);

    // Check 2: CSRF Indicators
    const csrfFindings = this.checkCSRF(body, config.checkWeights);
    findings.push(...csrfFindings);

    // Check 3: Clickjacking
    const clickjackingFindings = this.checkClickjacking(body, config.checkWeights);
    findings.push(...clickjackingFindings);

    // Check 4: Protocol Handler Abuse
    const protocolFindings = this.checkProtocolAbuse(body, config.checkWeights);
    findings.push(...protocolFindings);

    const score = this.calculateScore(findings, config.maxWeight);
    const duration = Date.now() - startTime;

    logger.info(`[Technical Exploits] Complete: ${score}/${config.maxWeight} points, ${findings.length} findings (${duration}ms)`);

    return {
      categoryId: this.categoryId,
      categoryName: this.categoryName,
      score,
      maxWeight: config.maxWeight,
      findings,
      metadata: {
        checksRun: 4,
        checksSkipped: 0,
        duration,
        skipped: false
      }
    };
  }

  /**
   * Check for XSS vulnerability indicators
   */
  private checkXSS(body: string, weights: Record<string, number>): Finding[] {
    const findings: Finding[] = [];
    let suspiciousPatternCount = 0;

    // Check for inline event handlers
    const inlineEvents = body.match(/on\w+\s*=\s*["'][^"']*["']/gi) || [];
    if (inlineEvents.length > 10) {
      suspiciousPatternCount++;
    }

    // Check for excessive JavaScript injection points
    const dangerousFunctions = [
      /document\.write/gi,
      /innerHTML\s*=/gi,
      /eval\s*\(/gi
    ];

    for (const pattern of dangerousFunctions) {
      const matches = body.match(pattern);
      if (matches && matches.length > 3) {
        suspiciousPatternCount++;
      }
    }

    // Check for user input reflection (common XSS vector)
    const hasUrlParams = body.includes('location.search') ||
                        body.includes('URLSearchParams') ||
                        body.includes('window.location.href');

    const hasDangerousOutput = /innerHTML|document\.write|eval/.test(body);

    if (hasUrlParams && hasDangerousOutput) {
      suspiciousPatternCount++;
    }

    if (suspiciousPatternCount >= 2) {
      findings.push(this.createFinding(
        'exploit_xss_indicators',
        'XSS Vulnerability Indicators',
        'medium',
        weights.exploit_xss_indicators || 6,
        `${suspiciousPatternCount} XSS risk indicators detected`,
        { count: suspiciousPatternCount }
      ));
    }

    return findings;
  }

  /**
   * Check for CSRF vulnerability indicators
   */
  private checkCSRF(body: string, weights: Record<string, number>): Finding[] {
    const findings: Finding[] = [];

    // Find POST forms
    const postForms = body.match(/<form[^>]*method\s*=\s*["']post["'][^>]*>[\s\S]*?<\/form>/gi) || [];

    let formsWithoutToken = 0;

    for (const form of postForms) {
      // Check for CSRF token (common names)
      const hasToken = /csrf|token|_token|authenticity_token/i.test(form) &&
                       /type\s*=\s*["']hidden["']/i.test(form);

      if (!hasToken) {
        formsWithoutToken++;
      }
    }

    if (formsWithoutToken >= 2) {
      findings.push(this.createFinding(
        'exploit_csrf_indicators',
        'CSRF Vulnerability Indicators',
        'medium',
        weights.exploit_csrf_indicators || 5,
        `${formsWithoutToken} POST forms without CSRF protection`,
        { count: formsWithoutToken }
      ));
    }

    return findings;
  }

  /**
   * Check for clickjacking attempts
   */
  private checkClickjacking(body: string, weights: Record<string, number>): Finding[] {
    const findings: Finding[] = [];
    const matches: string[] = [];

    for (const pattern of TechnicalExploitsCategory.CLICKJACKING_PATTERNS) {
      if (pattern.test(body)) {
        matches.push(pattern.source);
      }
    }

    // Check for overlapping elements (common clickjacking technique)
    const hasHighZIndex = /z-index\s*:\s*99\d+/i.test(body);
    const hasAbsolutePos = /position\s*:\s*absolute/i.test(body);
    const hasTransparent = /opacity\s*:\s*0/i.test(body);

    if ((hasHighZIndex && hasAbsolutePos) || hasTransparent) {
      findings.push(this.createFinding(
        'exploit_clickjacking',
        'Clickjacking Attempt',
        'medium',
        weights.exploit_clickjacking || 4,
        'Suspicious element positioning detected',
        { patterns: matches }
      ));
    }

    return findings;
  }

  /**
   * Check for protocol handler abuse
   */
  private checkProtocolAbuse(body: string, weights: Record<string, number>): Finding[] {
    const findings: Finding[] = [];
    const abusedProtocols: string[] = [];

    // Check for data: URIs (can be used for XSS)
    if (/href\s*=\s*["']data:/i.test(body)) {
      abusedProtocols.push('data:');
    }

    // Check for javascript: protocol
    if (/href\s*=\s*["']javascript:/i.test(body)) {
      abusedProtocols.push('javascript:');
    }

    // Check for vbscript: protocol (IE)
    if (/href\s*=\s*["']vbscript:/i.test(body)) {
      abusedProtocols.push('vbscript:');
    }

    if (abusedProtocols.length > 0) {
      findings.push(this.createFinding(
        'exploit_protocol_abuse',
        'Protocol Handler Abuse',
        'low',
        weights.exploit_protocol_abuse || 3,
        `Uses suspicious protocols: ${abusedProtocols.join(', ')}`,
        { protocols: abusedProtocols }
      ));
    }

    return findings;
  }
}
