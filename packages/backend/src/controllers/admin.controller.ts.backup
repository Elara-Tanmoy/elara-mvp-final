import { Request, Response } from 'express';
import { prisma } from '../config/database.js';
import { logger } from '../config/logger.js';
import { hashPassword } from '../utils/auth.js';

export class AdminController {
  // Get dashboard stats
  async getDashboardStats(req: Request, res: Response): Promise<void> {
    try {
      const [
        totalScans,
        totalOrganizations,
        totalUsers,
        threatsDetected,
        recentScans
      ] = await Promise.all([
        prisma.scanResult.count(),
        prisma.organization.count(),
        prisma.user.count(),
        prisma.scanResult.count({ where: { riskLevel: { in: ['high', 'critical'] } } }),
        prisma.scanResult.findMany({
          take: 10,
          orderBy: { createdAt: 'desc' },
          include: {
            user: { select: { email: true, firstName: true, lastName: true } },
            organization: { select: { name: true } }
          }
        })
      ]);

      res.json({
        stats: {
          totalScans,
          totalOrganizations,
          totalUsers,
          threatsDetected
        },
        recentScans: recentScans.map(scan => ({
          id: scan.id,
          type: scan.scanType,
          riskLevel: scan.riskLevel,
          riskScore: scan.riskScore,
          user: scan.user ? `${scan.user.firstName} ${scan.user.lastName}` : 'Unknown',
          organization: scan.organization?.name || 'Unknown',
          createdAt: scan.createdAt
        }))
      });
    } catch (error) {
      logger.error('Error fetching dashboard stats:', error);
      res.status(500).json({ error: 'Failed to fetch dashboard stats' });
    }
  }

  // List all organizations
  async getOrganizations(req: Request, res: Response): Promise<void> {
    try {
      const organizations = await prisma.organization.findMany({
        include: {
          _count: {
            select: { users: true, scanResults: true }
          }
        },
        orderBy: { createdAt: 'desc' }
      });

      res.json({
        organizations: organizations.map(org => ({
          id: org.id,
          name: org.name,
          tier: org.tier,
          usersCount: org._count.users,
          scansCount: org._count.scanResults,
          createdAt: org.createdAt,
          apiKey: org.apiKey
        }))
      });
    } catch (error) {
      logger.error('Error fetching organizations:', error);
      res.status(500).json({ error: 'Failed to fetch organizations' });
    }
  }

  // Update organization tier
  async updateOrganizationTier(req: Request, res: Response): Promise<void> {
    try {
      const { id } = req.params;
      const { tier } = req.body;

      if (!['free', 'pro', 'enterprise'].includes(tier)) {
        res.status(400).json({ error: 'Invalid tier' });
        return;
      }

      const organization = await prisma.organization.update({
        where: { id },
        data: { tier }
      });

      res.json({ organization });
    } catch (error) {
      logger.error('Error updating organization tier:', error);
      res.status(500).json({ error: 'Failed to update organization' });
    }
  }

  // List all users
  async getUsers(req: Request, res: Response): Promise<void> {
    try {
      const users = await prisma.user.findMany({
        include: {
          organization: { select: { name: true, tier: true } },
          _count: { select: { scanResults: true } }
        },
        orderBy: { createdAt: 'desc' }
      });

      res.json({
        users: users.map(user => ({
          id: user.id,
          email: user.email,
          firstName: user.firstName,
          lastName: user.lastName,
          role: user.role,
          organization: user.organization?.name,
          tier: user.organization?.tier,
          scansCount: user._count.scanResults,
          createdAt: user.createdAt,
          lastLogin: user.lastLogin
        }))
      });
    } catch (error) {
      logger.error('Error fetching users:', error);
      res.status(500).json({ error: 'Failed to fetch users' });
    }
  }

  // Update user role
  async updateUserRole(req: Request, res: Response): Promise<void> {
    try {
      const { id } = req.params;
      const { role } = req.body;

      if (!['owner', 'admin', 'member'].includes(role)) {
        res.status(400).json({ error: 'Invalid role' });
        return;
      }

      const user = await prisma.user.update({
        where: { id },
        data: { role }
      });

      res.json({ user });
    } catch (error) {
      logger.error('Error updating user role:', error);
      res.status(500).json({ error: 'Failed to update user' });
    }
  }

  // Deactivate user
  async deactivateUser(req: Request, res: Response): Promise<void> {
    try {
      const { id } = req.params;

      await prisma.user.delete({
        where: { id }
      });

      res.json({ message: 'User deactivated successfully' });
    } catch (error) {
      logger.error('Error deactivating user:', error);
      res.status(500).json({ error: 'Failed to deactivate user' });
    }
  }

  // Get all scans with filters
  async getAllScans(req: Request, res: Response): Promise<void> {
    try {
      const {
        riskLevel,
        scanType,
        organizationId,
        limit = '50',
        offset = '0'
      } = req.query;

      const where: any = {};
      if (riskLevel) where.riskLevel = riskLevel;
      if (scanType) where.scanType = scanType;
      if (organizationId) where.organizationId = organizationId;

      const [scans, total] = await Promise.all([
        prisma.scanResult.findMany({
          where,
          take: parseInt(limit as string),
          skip: parseInt(offset as string),
          orderBy: { createdAt: 'desc' },
          include: {
            user: { select: { email: true, firstName: true, lastName: true } },
            organization: { select: { name: true } }
          }
        }),
        prisma.scanResult.count({ where })
      ]);

      res.json({ scans, total });
    } catch (error) {
      logger.error('Error fetching scans:', error);
      res.status(500).json({ error: 'Failed to fetch scans' });
    }
  }

  // Get audit logs
  async getAuditLogs(req: Request, res: Response): Promise<void> {
    try {
      const { limit = '100', offset = '0' } = req.query;

      const [logs, total] = await Promise.all([
        prisma.auditLog.findMany({
          take: parseInt(limit as string),
          skip: parseInt(offset as string),
          orderBy: { timestamp: 'desc' },
          include: {
            user: { select: { email: true, firstName: true, lastName: true } },
            organization: { select: { name: true } }
          }
        }),
        prisma.auditLog.count()
      ]);

      res.json({ logs, total });
    } catch (error) {
      logger.error('Error fetching audit logs:', error);
      res.status(500).json({ error: 'Failed to fetch audit logs' });
    }
  }

  // Get system metrics
  async getSystemMetrics(req: Request, res: Response): Promise<void> {
    try {
      const [
        scansLast24h,
        scansLast7d,
        scansLast30d,
        avgRiskScore,
        scansByType,
        scansByRiskLevel
      ] = await Promise.all([
        prisma.scanResult.count({
          where: { createdAt: { gte: new Date(Date.now() - 24 * 60 * 60 * 1000) } }
        }),
        prisma.scanResult.count({
          where: { createdAt: { gte: new Date(Date.now() - 7 * 24 * 60 * 60 * 1000) } }
        }),
        prisma.scanResult.count({
          where: { createdAt: { gte: new Date(Date.now() - 30 * 24 * 60 * 60 * 1000) } }
        }),
        prisma.scanResult.aggregate({
          _avg: { riskScore: true }
        }),
        prisma.scanResult.groupBy({
          by: ['scanType'],
          _count: true
        }),
        prisma.scanResult.groupBy({
          by: ['riskLevel'],
          _count: true
        })
      ]);

      res.json({
        scans: {
          last24h: scansLast24h,
          last7d: scansLast7d,
          last30d: scansLast30d
        },
        avgRiskScore: avgRiskScore._avg.riskScore || 0,
        scansByType,
        scansByRiskLevel
      });
    } catch (error) {
      logger.error('Error fetching system metrics:', error);
      res.status(500).json({ error: 'Failed to fetch system metrics' });
    }
  }
}

export const adminController = new AdminController();
